# 第1章 面试的流程
如果应聘者在面试的时候**没有听清**或者**没有听懂**面试官的问题时，
千万不要不懂装懂、答非所问。一定要大胆地向面试官多提问，直到弄清楚面试官的意图为止。
敢于说Pardon(对不起)

 - 自我介绍
    
     用30秒到1分钟的时间介绍自己的主要学习、工作经历即可
 
 - 项目经验 (STAR模型)
    - Situation:简短的项目背景，比如项目的规模，开发的软件的功能、目标用户等。
    - Task:自己完成的任务。负责了什么，参与了什么
    - Action:为了完成任务自己做了哪些工作，是怎么做的
    - Result:自己的贡献。这个一定要具体、量化（最好用数字加以说明）
 
 - 你在该项目中碰到的最大的问题是什么，你是怎么解决的？
 
 - 从这个项目中你学到了什么？
 
 - 什么时候会和其他团队成员（包括开发人员、测试人员、设计人员、项目经理等）
   
   有什么样的冲突，你们是怎么解决冲突的？
 
 - 🌟回答"为什么跳槽"
    
    尽量避免以下4个原因
    - 老板太苛刻
    - 同事太难相处
    - 加班太频繁
    - 工资太低
    
    🚩参考答案：
    1. 我在xx开发一款面向xx的软件，如果我想在现在的职位上得到提升，就必须加强
    xx行业的学习，可是我对xx等没有太多兴趣，因此出来寻找机会。
    2. 主要维护xx非常成熟的平台，因此平时工作主要是维护和修改BUG，在xx方向得到
    很大的提高，但长期如此在xx上得不到提高，因此想出来寻找可以xx的职位。众所周知，
    贵公司在xx方向上行业佼佼者，因此对贵公司很感兴趣。
    
 - 💪技术面
 
    - 清晰的思路
    - 优化效率的能力
    
      面试官出的题目有多种解法的时候，通常他会期待应聘者最终能够找到最优解。
      应聘者应该在时间消耗或空间消耗上对比优化。
      要想优化**时间效率**或者**空间效率**，首先要知道如何分析效率。
      优化代码的效率，还要熟知各种数据结构的优缺点以及常用的算法。
    - 优秀的综合能力（沟通能力、学习能力、知识迁移能力）
    
 - 应聘者提问环节
    - 不要问薪水，要谈工资要等通过面试之后和HR谈。
    - 不要立即打听面试结果
    
    🚩参考答案：
    1. 内部培训，是否有机会去总公司内部学习
    2. 对职位相关的硬性要求和其他软技能有什么要求
    

# 第2章 面试需要的基础知识

## 面试题1：赋值运算符函数
考察异常安全性(Exception Safety)原则
有两种方法：
 1. 先用`new`分配新内容再用`delete`释放已有的内容
 2. 创建一个临时实例`strTemp`，接着与实例自身来回替换
    ES6有优化`[a,b] = [b,a]`
    
## 面试题2：实现Singleton模式
单线程 按需创建实例
```java
public class CrimeLab {
    private static CrimeLab sCrimeLab;

    public static CrimeLab get(Context context){
        if(sCrimeLab == null){
            sCrimeLab = new CrimeLab(context);
        }
        return sCrimeLab;
    }
    
    private CrimeLab(Context context){
        // 业务代码
    }
}
```

## 面试题3：二维数组中的查找
> 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，
> 每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一
> 个二维数组和一个整数，判断数组中是否含有该整数。

 - 考察二维数组的理解及编程能力
 - 考察分析问题的能力。遇到问题比较复杂时，
 能不能通过具体的例子来找出其中的规律。
 
 这道题就是**从右到左**递减找出存在的那一列，
 然后**从上到下**递增定位到那一列的这一行，如果没有就重复上述**再从右到左**
 
 ⚠️测试用例：
 - 二维数组中没有查找的数字（为递归做及时退出保护）
 - 特殊输入测试（输入空指针）
 
## 面试题4：替换空格
> 题目：请实现一个函数，把字符串中的每个空格替换成"%20"。
> 例如输入"We are happy"，则输出"We%20are%20happy"。

 - 时间复杂度为**O(n^2)**的解法
 
    从左往右循环找出空格并依次替换，
    这样会导致每次找出并替换时，后面的字符都需要要向右位移"%20"三个格子
    
 - 时间复杂度为**O(n)**的解法
 
 第一次出现双指针
 
    1. 先遍历一次字符串（这样就能统计出字符串中空格的总数，并计算替换后字符串的长度）
    2. 准备两个指针P1和P2(本书第一次出现的**双指针解法**，后面还有很多问题可以利用**双指针解法**优化)
    3. P1指向字符串的末尾，P2指向替换后的字符串的末尾（空格总数乘以替换后的长度差）
    4. P1向左移动，逐个把碰到的字符串复制给P2的位置。碰到第一个空格时，再向P2传输"%20"3个字符串，
       然后p2移动到"%"之前的空格处。
    5. 重复第3步和第4步
    
 ⚠️测试用例：
  - 输入的字符串没有空格
  - 特殊输入测试（字符串是个NULL指针、空字符串、只有一个空字符、字符串中只有连续多个空格）
 
 🚩举一反三：
  - 合并两个数组
    
    如果从前往后复制每个数字，需要重复移动数字多次<br/>
    我们可以考虑从后往前复制，这样能减少移动的次数
    
## 面试题5：从尾到头打印链表
> 题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。

回答问题之前，大胆问面试官**是否允许在打印链表的时候修改链表的结构？**
   - 如果可以改变（一般打印是一个只读操作），遍历一遍，将next值改成前一个
     再遍历一遍被改后的链表
   - 如果不可以改变，典型的"后进显出"，所以需要额外空间-栈，每经过一个结点的时候，把这个结点放到栈中，
     遍历完链表后，再遍历一遍栈
   - 利用递归的调用栈特性<br/>
     递归遍历链表，然后打印每一个next，输出顺序自然是从底层往上输入
     
  ⚠️测试用例：
   - 功能测试（输入的链表有多个结点、一个结点）
   - 特殊输入测试（链表表头结点指针为NULL）
   
  🚩本题考点：
   - 单向链表的理解和编程能力
   - 循环、递归和栈 三个概念的理解

## 面试题6：重建二叉树
> 题目：输入某二叉树的**前序遍历**和**中序遍历**结果，请重建该二叉树。
> 假设都不存在重复的数字。
> 如前序遍历结果{1,2,4,7,3,5,6,8}和中序遍历结果{4,7,2,1,5,3,8,6}

```
        1
       2  3
     4   5 6
      7     8
```
解法：从前序中获得根结点
在中序中以该结点，获得左和右结点
重复上述


1为根结点，中序可分为{4,7,2}和{5,3,8,6}
中序{5,3,8,6}中因为前序{3,5,6,8}所以3为根结点,5在左边
中序{6,8},前序{6,8}，6为根结点，8在6的右边

  🚩本题考点：
   - 前序遍历： 根 > 左 > ~ > 左 > 右 (特点：第一个永远为根结点，如果是二叉搜索树的话就是一个顺序递增的结果)
   - 中序遍历： 左 > 根 > 右 > 根（在已知根结点的情况下，左结点永远为左，右结点永远在右）
   - 后序遍历： 左 > 右 > 根（深度优先遍历，特点：最后一个永远为根结点）

## 面试题7：用两个栈实现队列
  🚩本题考点：
   - 栈Stack：先进后出
   - 队列Queue：先进先出
   - 拓展：用两个队列实现一个栈
   
## 面试题8：旋转数组的最小数字 - 二分查找
> 题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为**数组的旋转**。
> 输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如[3,4,5,1,2]为
> [1,2,3,4,5]的一个旋转，该数组的最小值

 - O(n)解法，从头到为遍历一遍
 - O(log n)解法（利用双指针实现二分查找）
   
   第一个指针P1指向第一个元素，第二个指针P2指向最后一个元素
   如果中间的数字比P1大，比P2小，将P1移动到中间的数字
   如果中间的数字比P1小，比P2大，将P2移动到中间的数字
   直到P1与P2相邻时，P2所指的数字就是最小的数字
   
## 面试题9：斐波那契数列

 - O(n)
  前提是使用缓存优化后的斐波那契递归函数
  ```
  f(n) = f(n-1)+f(n-2)
  ```
 - O(log n)
  生僻公式

## 面试题10：二进制中1的个数 - 位与运算
> 题目：请实现一个函数，输入一个整数，输出该树二进制表示中1的个数。
> 例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。

 - 常规解法：先转成二进制，从右往左循环，是1就自增
 - 位与运算(相同的返回1，不相同的返回0)：
   第一步：一个整数和它减去1的结果做**位与运算**；
   记录次数+1；
   第二步：再把这个整数和第一步返回的结果做**位与运算**
   ```
    int NumberOf1(int n){
       int count = 0;
   
       while(n){
         ++count;
         n = (n - 1) & n;
       }
   
       return count;
    }
   ```
  
  ⚠️测试用例：
   - 正数（包括边界值1、0x7FFFFFFF）
   - 负数
   - 0
  
  🚩本题考点：
   - 考查 二进制和位运算 的理解
   - 考查分析、调试代码的能力（如出现负数时会出现死循环）
   
  ❓举一反三：
   - 只用**一条语句**判断一个整数是不是2的整数次方。
    （如果是，那么转换成二进制只会有1个1，所以 `(n & (n-1)) === 0`）
   - 任意进制转换
     ```javascript
        function translate(int,type){
            if(int > type){
                return translate(Math.floor(int/type),type) + " " + int%type
            }else {
                return int
            }
        }
    ```
    
    
## 拓展知识 - 异或运算（位运算bit operation）
||||||
|----|----|----|----|----|
|与（&）| `0&0 = 0` | `1&0 = 0` | `0&1 = 0` | `1&1 = 1`|
|或（ I ）| `0I0 = 0` | `1I0 = 1` | `0I1 = 1` | `1I1 = 1` |
|异或（^）| `0^0 = 0` | `1^0 = 1` | `0^1 = 1` | `1^1 = 0` |

 - `&` 不相等为0，相等于为当前值
 - `|` 不相等为1，相等为当前值
 - `^` 不相等为1，相等为0
 - `～` 去反操作 ~a = (a+1)*(-1)
 - `>>` 
 - `<<` a<<2 表示1左移2位
 - `>>>` 

# 第3章：高质量的代码

> *"我会从程序的**正确性**和**鲁棒性**两方面检验代码的质量。会关注*
> *对 **输入参数的检查**、**处理错误和异常的方式**、**命名方式**等。对于没有工作*
> *经验的学生，程序正确性之外的错误基本能容忍，但经过提示后希望*
> *能够很快解决。**对于有工作经验的人，不能容忍考虑不周到、有明显鲁棒性错误。**"*

## 面试题11：数值的整数次方
> 题目：实现函数 double Power(double base,int exponent)，求base的
> 指数(exponent)次方。不得使用库函数(如`pow(b,e)`)，同时不需要考虑大数问题。

 - 自以为题目简单的解法：循环exp，然后base自乘
   没有考虑到exp的正负
 - 考虑代码完整性：（功能测试、边界测试、负面测试3个方面设计测试用例）、
   以及错误处理（返回值、全局代码和异常），如`0的0次方应该返回多少`、
   最小边界值是多少`0.00000001`(还会由于精度原因不能用等号判断两个小数是否相等)
 - 全面又高效的解法：代码完整性后，还要提高效率。
   循环乘法自增会重复计算，可以应用斐波那契数列递归来优化重复计算，
   如32次方 等于 16次方再2次方法，我们已经知道16次方的值，直接2次方即可获得结果
   ```
   // n为偶数
   a^n = a^(n/2) * a^(n/2)
   
   // n为奇数
   a^n = a^[(n-1)/2] * a^[(n-1)/2] * a
    
   ```
   常规代码（斐波那契数列） 这里只考虑大于等于0的情况
   ```javascript
    function _pow(base, exponent){
       if(exponent === 0){
           return 1
       }else if(exponent === 1){
           return base
       }else {
           // 为偶数次方时
           if(exponent % 2 === 0){
               return _pow(base, exponent/2) * _pow(base, exponent/2)
           }else { // 为奇数次方时
               return _pow(base, (exponent-1)/2) * _pow(base, (exponent-1)/2) * base
           }
       }
    }
   ```
   优化
   ```javascript
    function _pow(base, exponent){
       if(exponent === 0){
          return 1
       }else if(exponent === 1){
          return base
       }
   
       // 斐波那契最大的特点就是重复运算之前已经计算过的
       // 我们可以优化演变为如 32次方等于 16的平方； 5次方等于2的平方再乘以自身一倍
       var result = _pow(base, exponent >> 1); // 「 >> 1 」 求2的最大整数倍
       result *= result;   //平方操作
       if(result & 0x1 === 1){     // 「 & 0x1 」 求奇(结果为1)偶(结果为0)
           result *= base;
       }
   
       return result
    }
   ```
   
  ⚠️测试用例：
   - 把底数和指数分别设为正数、负数和零
   
  🚩本题考点：
   - 考查思维的全面性。问题本身不难
   - 将效率提高到极致：位运算比乘除运算以及求余运算效率高得多

## 面试题12：打印1到最大的n位数 - 🎰
> 题目：输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，
> 则打印出1、2、3一直到最大的3位数即999。

 - 在字符串上模拟数字加法的解法：
   考虑到"大数问题"（int自增到long时会溢出），用字符串模拟。
   如打印到5位数时，从"00001"、"00002"一直到"99999"。再额外加一个函数
   只打印碰到第一个非0的字符
 - 把问题转换成数字排列的解法，递归让代码更简洁
   上一个解法很难在短时间内写完。既然都是要从0自增到9，
   不如用递归在每一个位数字进行递归（有点像老虎机🎰）
   
## 面试题13：在O(1)时间删除链表结点
> 题目：给定单向链表的头指针和一个结点指针，定义一个函数在O(1)
> 时间删除该结点。

 - 关键词不在delete。将上一个结点的next指定到需要被删除结点的next，
   该结点自动脱离了链表
   
  ⚠️测试用例：
   - 功能测试（删除尾结点、删除唯一结点、删除头结点）
   - 特殊输入测试（NULL指针）
  
  🚩本题考点：
   - 考查对链表的编程能力
   - 考查创新思维能力（DO NOT FOCUS delete）
   - 老规矩，思维的全面性，代码的鲁棒性完整性。
   
## 面试题14：调整数组顺序使奇数位于偶数前面 - 拓展性
> 题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，
> 使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

 - 只完成当前的基础功能的解法，仅适用于初级程序员
   没有额外的空间，使用双指针。指针A指向第一个，指针B指向最后一个。
   移动A指针，发现是奇数，继续移动；发现是偶数，关注点来到B，如果是奇数和A交换，如果是偶数，向前移动
 - 考虑可扩展性的解法：如果条件从奇偶数换成"能否被3整除"或者其他方法怎么办？
   1.将指针移动和交换的条件分离出来 做一个boolean函数
   2.（效率较低）在JavaScript中添加一个额外的空间，使用foreach将抽离的条件带入进去
     将符合条件的push到额外空间中，原数组splice操作。循环结束后，再push原数组剩下的
     
   🚩本题考点：
    - 代码的扩展性、可重用性
    
    
## 面试题15：链表中倒数第k个结点 - 鲁棒性
> 题目：输入一个链表，输出该链表中倒数第k个结点。

 - 从头到尾遍历一遍链表，获得链表长度l。再从l-k开始遍历到最后。
   缺点：时间效率低（要遍历2次链表）、鲁棒性差（循环链表怎么办）
 - 双指针只循环一次：p1、p2都在起点；p2保持不动，p1向前走k-1；
   p1到达后，p1、p2联动向前。当p1到达尾部时，p2刚好指向第k个结点。
   
   ⚠️测试用例：
    - 功能测试（k结点在表头、k结点在链表中间、k结点在表尾）
    - 特殊输入测试（NULL 、链表的结点总数小于k）
    
   🚩本题考点：
    - 考查对链表的理解
    - 考查代码的鲁棒性（鲁棒性，Robust的音译，有时也翻译成健壮性）。容错性是鲁棒性
      的一个重要体现。

## 面试题16：反转链表 - 指针操作容易出错
> 题目：定义一个函数，输入一个链表的头结点，反转该链表并输出
> 反转后链表的头结点。

 - 解决与链表相关的问题总是有大量的指针操作，而指针操作的代码总是容易出错的。
 - 用递归实现反转链表的功能
 
    ⚠️测试用例：
     - 输入的链表头指针是NULL
     - 输入的链表只有一个结点
     - 输入的链表有多个结点
     
## 面试题17：合并两个排序的链表
> 题目： 1->3->5->7->9 和 2->4->6->8 合并成
> 1->2->3->4->5->6->7->8->9

 - 双指针，P1指向链表A第一个，P2指向链表B第一个。同时向前

## 面试题18：树的子结构
> 题目：输入两棵二叉树A和B，判断B是不是A的子结构。

 - 和链表相比，树中的指针操作更多也更复杂。
 - 个人解法：中序遍历和前序遍历。然后找数组Aarr中有没有Barr片段




   🚩本章考点
    - 规范性
      书写清晰、布局清晰、命名规范
    - 完整性
      完成基本功能、考虑边界条件、做好错误处理
    - 鲁棒性
      采取防御式编程、处理无效的输入
      
# 第4章 解决面试题的思路

> 画图让抽象问题形象化

## 面试题19：二叉树的镜像
 - 递归将left和right值互换

## 面试题20：顺时针打印矩阵

```
1  2  3   4
5  6  7   8
9 10  11 12
```
输出结果 1、2、3、4、8、12、11、10、9、5、6、7

> 举例让抽象问题具体化

## 面试题21：包含min函数的栈 `MinInStack`
> 题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小
> 元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。

 - 看到这个问题，我们的第一反应可能是**每次压入一个新的元素进栈时，将栈里的所有元素排序，让最小的元素位于栈顶**，
   这样就能在O(1)时间得到最小元素了。*但这种思路不能保证最后压入栈的元素能够最先出栈*，因此
   这个数据结构已经不是栈了。
 - 我们接着想到在栈里添加一个成员变量存放最小的元素。每次压入新元素时都要和该成员变量里的元素对比，
   随时更新最小元素。**但是如果当前最小元素被弹出栈时，如何得到下一个最小的元素呢？**
 - 综上，最终解可以是：**创建一个辅助栈和一个数据栈**。数据栈正常压入弹出，辅助栈负责存储数据栈排序后的值。

## 面试题22：栈的压入、弹出序列
> 题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第
> 二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如
> 序列1、2、3、4、5是某栈的压栈序列，序列4、5、3、2、1是该压栈序
> 列对应的一个弹出序列，但4、3、5、1、2就不可能是该压栈序列额度弹出
> 序列。

 - 解决这个问题很直观的想法就是建立一个辅助栈，把输入的第一个序
   列中的数字依次压入该辅助栈，并按照第二个序列的顺序依次从该栈中弹
   出数字。
   

> 🌟 二叉树遍历专题

|遍历类型|过程|
|----|----|
|前序遍历|根 > 左 > ... > 左 > 右|
|中序遍历|左 > 根 > 右|
|后序遍历|左 > 右 > 根(深度优先遍历)|

 - 递归
```javascript
function orderTraverseNode(tree){
    if(tree !== null){
        print(tree.key);
        orderTraverseNode(tree.left);
        orderTraverseNode(tree.right);
    }
}

orderTraverseNode(tree)
```
 - 非递归遍历
```javascript

```

## 面试题23：从上往下打印二叉树
> 题目：从上往下打印出二叉树的每个结点，同一层的结点按照从左到
> 右的顺序打印。

 - 该题亦称"广度优先遍历"或"宽度优先遍历"(BFS, breath-first traversal)
   不管是广度优先遍历一个有向图还是一棵树，**都要用到队列**
   
   ```javascript
   function BFS(tree){
       var queue = new Queue();
       
       if(tree) queue.enqueue(tree)
   
       while(!queue.isEmpty()){
           var currentTree = queue.dequeue();
           print(currentTree.key);
   
           if(currentTree.left) queue.enqueue(currentTree.left)
           if(currentTree.right) queue.enqueue(currentTree.right)
       }
   }
   
   BFS(tree)
   ```
   
## 面试题24：二叉搜索树的后序遍历序列
> 题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后续遍
> 历的结果。

 - 后序遍历结果的数组最后一个值永远是树的根结点
   比根结点小的永远在根的左边，因此可以将数组除了最后一个值之外，一分为二
   
   
   分开来的数组，分别递归上述操作，判断左子树是否大于右子树
   

   🚩相关题目
    - 输入一个整数数组，判断该数组是不是某二叉搜索树的前序遍历的结果。
      （这和后序遍历很类似，只是在前序遍历得到的序列中，第一个数字是根结点的值）
      
      
## 面试题25：二叉树中和为某一值的路径
> 题目：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输
> 入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形
> 成一条路径。

 - **路径**是一个新概念。对概念不清晰的话，我们可以试着从一两个具体的例子入手，找到规律。
   从根结点开始的遍历在**前序、中序、后序**三种遍历方式中
   只有**前序**是从根结点开始的，所以我们用前序遍历来记录**路径**。
 - 如下图,求值等于22的路径
   ```bash
      10
    5   12
   4 7
   ```
   前序遍历 `10 > 5 > 4`，路径记录下来发现值不对，这是为了不继续向4那边遍历，
   我们需要将4从树中删除，即`5.left = null`
   接下来继续前序遍历
   
   
   
> 分解让复杂问题简单化 `分治法`


## 面试题26：复杂链表的复制
> 题目：请实现函数ComplexListNode*Clone(ComplexListNode*pHead),
> 复制一个复杂链表。在复杂链表中，每个结点除了有一个m_pNext指针
> 指向下一个结点外，还有一个m_pSibling指向链表中的任意结点或者NULL。

```c++
struct COmplexListNode
{
    int                 m_nValue;
    ComplexListNode*    m_pNext;
    ComplexListNode*    m_pSibling;
}
```
**注：在复杂链表的结点中，除了有指向下一结点的指针（实线箭头）**
**外，还有指向任意结点的指针（虚线箭头）**

 - 时间复杂度O(n^2)：第一步先复制原始链表上的每一个结点，并用 m_pNext 链接起来；
   第二步是设置每个结点的 m_pSibling 指针。
 - 空间换时间：第一步和上一方案一样先确定m_pNext，不过我们用<N, N'>的配对信息
   方法放到一个哈希表中，第二步还是设置复制链表上每个绩点的m_pSibling。不过不用再
   回过头遍历，直接在哈希表O(1)中查找。最终时间复杂度为O(n*1) = O(n)
   
   🚩相关题目
    - JavaScript `JSON.stringify()`解析一个循环对象

## 面试题27：二叉搜索树与双向链表
> 题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向
> 链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

```bash
    10
 6     14
4 8  12 16

4 <=> 6 <=> 8 <=> 10 <=> 12 <=> 14 <=> 16 
```

 - 分治法：先中序遍历 获得[4 6 8 10 12 14 16]的数组,
   已知根为10，所以我们将10左右的两个值与10链接起来
   
## 面试题28：字符串的排列
> 题目：输入一个字符串，打印出该字符串中字符的所有排列。
> 例如输入字符串abc，则打印出abc,acb,bac,bca,cab,cba。

 - 将复杂的问题分解成小的问题：
   把字符串分为两部分，一部分是字符串的第一个字符，另一部分是第一个字符以后的所有字符
   我们对另一部分进行排列
   
   
   这是一个典型的递归思路，不论多少个字符串，始终都会回到3个字符串的情况：
   第一个一共有3中可能，确定以后，后面2个字符串共2种可能，即3\*2\*1
   ```javascript
    var a = ['a','b','c'];

    function print(a,j=1){
        console.log(a[0]+a[1]+a[2]);
        console.log(a[0]+a[2]+a[1]);
        if(a.length > j){   //递归最重要的就是结束条件
            let temp = a[j];
            a[j] = a[0];
            a[0] = temp;
            print(a,j+1)
        }
    }

    print(a)
   ```
