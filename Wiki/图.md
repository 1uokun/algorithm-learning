# 图
图是网络结构的抽象模型。图是一组由**边**连接的**节点**（或**顶点**）。
学习图是重要的，因为**任何二元关系都可以用图来表示**（如社交网络
、道路、航班以及通信）。

## 邻接矩阵
图最常见的实现是**邻接矩阵**。每个节点都和一个整数相关联，该整数将作为数组的索引。
我们用一个**二维数组**来表示顶点之间的连接。
如果索引为*i*的节点和索引为*j*的节点相邻，则`array[i][j] = 1`,否则`array[i][j] = 0`。

```
/**

  A B C D
A 0 1 1 1
B 1 0 0 0
C 1 0 0 1
D 1 0 1 0

**/
```

不是强连通的图（**稀疏图**）如果用邻接矩阵来表示，则矩阵中将会有很多0，这意味着我们
浪费来计算机存储空间来表示根本不存在的边。例如，找给定顶点的相邻顶点，即使该顶尖只有
一个相邻顶点，我们也不得不迭代一整行。邻接矩阵表示不够好的另一个理由是，图中顶点的数量
可能会改变，而二维数组不太灵活。


## 邻接表
我们也可以使用一种叫作**邻接表**的动态数据结构来表示图。邻接表由图中每个顶点的相邻顶点
列表所组成。存在好几种方式来表示这种数据结构。我们可以用列表（数组）、链表，甚至是
散列表或是字典来表示相邻顶点列表。

```
/**

A : B C D 
B : A
C : A D
D : A C

**/
```

尽管邻接表可能堆大多数问题来说都是更好的选择，但以上两种表示法都很有用，且它们有
着同的性质（例如，要找出顶点v和w是否相邻，使用邻接矩阵会比较快）。

## 关联矩阵
还可以用**关联矩阵**来表示图。在关联矩阵中，矩阵的行表示顶点，列表示边。
如果顶点v是边e的入射点（无向：即e在v和其他顶点相连这条线上，有向：v->*，e在这条线上）,
则`array[v][e] = 1`

```
/**

  v1 v2 v3 v4
A 1  1  0  1
B 1  0  0  0
C 0  1  1  0 
D 0  0  1  1

**/
```
关联矩阵通常用于边的数量比顶点多的情况，以节省空间和内存。

# 图的遍历

## 深度优先搜索
利用递归的调用栈顺序，从底层往外执行

## 广度优先搜索
利用辅助空间队列，将每一层的顶点存入到队列中，遍历完队列后，再依次从左到右
生成队列，重复这一动作。
#### 1.使用BFS寻找最短路径
已经被探索过的就标记，避免被重复探索，特别是闭环很有用。
改进BFS，获得每个顶点距离初始顶点的距离，就能拿到A到其他顶点的最短路径
#### 2.深入学习最短路径算法
如果要计算加权图中的最短路径，广度优先搜索未必合适。（因为对于闭环，会优先探索左边的）
#### 3.Dijkstra算法
*Dijkstr*算法是一种计算从单个源到所有源的最短路径的贪心算法，这意味着我们可以用它来
计算从图的一个顶点到其余各顶点的最短路径。（基于有向图）

<img src="Dijkstr_example.png">

```
/**

  A B C D E F
A 0 2 4 0 0 0
B 0 0 2 4 2 0
C 0 0 0 0 3 0
D 0 0 0 0 0 2
E 0 0 0 0 0 2
F 0 0 0 0 0 0


**/

```


#### 4.Floyd-Warshall算法
*Floyd-Warshall*是一种计算图中所有最短路径的动态规划算法。
```
/**
  A B C D E F
A   2        
B     2   2  
C         3  
D            
E           2
F           0

各个最短路径
1.【A -> B】 2
2.【B -> C】 & 【B -> E】 2
3.1 【C -> E】 3
3.1.1 【E -> F】 2
3.2 【E -> F】 2

A -> B之后出现相同距离的分歧
再重新以各分歧为顶点
C -> E -> F
E -> F
动态规划在比较过程中不断筛选出最短路径，
最后再比较值
A:2 B:2 C:3 E:2 F
A:2 B:2 E:2 F
**/
```

# 帕斯卡三角形（也称杨辉三角）
> 什么是帕斯卡三角形？
> 在帕斯卡三角形中，每个数字都是上方与它相邻的两数之和。
> —— 摘自《程序员的数学》
```
            1
       1    2   1
    1    3    3   1
  1   4    6    4   1
1   5   10   10   5   1
```
通过帕斯卡三角形可以很容易获得**"从起点开始到本分叉点有几条路线**
